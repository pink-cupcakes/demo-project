name: "CodeQL Remediation Trigger"

on:
  issue_comment:
    types: [created]

jobs:
  trigger-remediation:
    if: github.event.issue.pull_request && contains(github.event.comment.body, '!codeql_remediation')
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
      issues: write
      security-events: read
      actions: write

    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      with:
        token: ${{ secrets.GITHUB_TOKEN }}
        fetch-depth: 0

    - name: Get PR details
      id: pr-details
      uses: actions/github-script@v7
      with:
        script: |
          const { data: pr } = await github.rest.pulls.get({
            owner: context.repo.owner,
            repo: context.repo.repo,
            pull_number: context.issue.number
          });
          
          core.setOutput('head_sha', pr.head.sha);
          core.setOutput('base_sha', pr.base.sha);
          core.setOutput('head_ref', pr.head.ref);
          core.setOutput('base_ref', pr.base.ref);
          core.setOutput('pr_number', pr.number);
          
          return pr;

    - name: Analyze CodeQL alerts for PR
      id: analyze-alerts
      uses: actions/github-script@v7
      with:
        script: |
          // Get all CodeQL alerts for the repository
          const { data: alerts } = await github.rest.codeScanning.listAlertsForRepo({
            owner: context.repo.owner,
            repo: context.repo.repo,
            per_page: 100,
            state: 'open'
          });
          
          // Filter alerts that are relevant to this PR's changes
          const prAlerts = [];
          const vulnerabilityGroups = {};
          
          for (const alert of alerts) {
            // Check if alert is in files changed by this PR
            const { data: files } = await github.rest.pulls.listFiles({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: context.issue.number
            });
            
            const changedFiles = files.map(f => f.filename);
            const alertFile = alert.most_recent_instance?.location?.path;
            
            if (alertFile && changedFiles.some(file => alertFile.includes(file) || file.includes(alertFile))) {
              prAlerts.push(alert);
              
              const ruleId = alert.rule.id;
              const severity = alert.rule.severity;
              const category = alert.rule.security_severity_level || severity;
              
              if (!vulnerabilityGroups[ruleId]) {
                vulnerabilityGroups[ruleId] = {
                  rule: alert.rule,
                  alerts: [],
                  severity: severity,
                  category: category
                };
              }
              vulnerabilityGroups[ruleId].alerts.push(alert);
            }
          }
          
          core.setOutput('pr_alerts_count', prAlerts.length);
          core.setOutput('vulnerability_groups', JSON.stringify(vulnerabilityGroups));
          
          // Comment on PR with analysis results
          const groupCount = Object.keys(vulnerabilityGroups).length;
          const vulnerabilityList = Object.entries(vulnerabilityGroups).map(([ruleId, group]) => 
            "- **" + ruleId + "** (" + group.severity + "): " + group.alerts.length + " instance(s) - " + group.rule.description
          ).join('\n');
          
          const groupSection = groupCount > 0 ? 
            "### Vulnerability Groups to be Addressed:\n" + vulnerabilityList + "\n\nðŸ¤– **Devin AI will create separate MRs for each vulnerability type against your feature branch.**" :
            'âœ… **No CodeQL alerts found in the changed files of this PR.**';
          
          const commentBody = "## ðŸ” CodeQL Remediation Analysis\n\n**Found " + prAlerts.length + " CodeQL alerts in this PR affecting " + groupCount + " vulnerability types.**\n\n" + groupSection + "\n\n---\n*Triggered by !codeql_remediation macro*";

          await github.rest.issues.createComment({
            owner: context.repo.owner,
            repo: context.repo.repo,
            issue_number: context.issue.number,
            body: commentBody
          });
          
          return { prAlerts, vulnerabilityGroups };

    - name: Trigger Devin AI Remediation
      if: steps.analyze-alerts.outputs.pr_alerts_count > 0
      uses: actions/github-script@v7
      with:
        github-token: ${{ secrets.GITHUB_TOKEN }}
        script: |
          const vulnerabilityGroups = ${{ steps.analyze-alerts.outputs.vulnerability_groups }};
          const prNumber = '${{ steps.pr-details.outputs.pr_number }}';
          const headRef = '${{ steps.pr-details.outputs.head_ref }}';
          
          // Call Devin AI directly for each vulnerability group
          for (const [ruleId, group] of Object.entries(vulnerabilityGroups)) {
            console.log(`Creating Devin AI session for ${ruleId} vulnerabilities...`);
            
            // Prepare detailed prompt for Devin AI
            const affectedFiles = [...new Set(group.alerts.map(alert => alert.most_recent_instance?.location?.path).filter(Boolean))];
            const alertDetails = group.alerts.map(alert => {
              const location = alert.most_recent_instance?.location;
              return "- **File:** " + (location?.path || 'Unknown') + " (Line " + (location?.start_line || 'Unknown') + ")\n  - **Message:** " + (alert.most_recent_instance?.message?.text || 'No message') + "\n  - **Alert URL:** " + alert.html_url;
            }).join('\n');
            
            const filesList = affectedFiles.map(file => "- " + file).join('\n');
            
            const prompt = "!codeql_remediation\n\n" +
              "**Repository:** " + context.repo.owner + "/" + context.repo.repo + "\n" +
              "**Branch:** " + headRef + "\n" +
              "**Original PR:** #" + prNumber + "\n" +
              "**Vulnerability Type:** " + ruleId + "\n" +
              "**Severity:** " + group.severity + "\n" +
              "**Alert Count:** " + group.alerts.length + "\n\n" +
              "**Affected Files:**\n" + filesList + "\n\n" +
              "**Alert Details:**\n" + alertDetails;
            
            // Call Devin API directly
            try {
              const response = await fetch('https://api.devin.ai/v1/sessions', {
                method: 'POST',
                headers: {
                  'Authorization': 'Bearer ${{ secrets.DEVIN_API_TOKEN }}',
                  'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                  prompt: prompt,
                  idempotent: true,
                  unlisted: false
                })
              });
              
              if (!response.ok) {
                const errorText = await response.text();
                console.log("Devin API call failed: " + response.status + " " + response.statusText + " - " + errorText);
                console.log("Creating tracking issue instead...");
                
                // Fallback: create tracking issue
                await github.rest.issues.create({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  title: "ðŸ¤– Devin AI: Fix " + ruleId + " vulnerabilities (" + group.severity + ")",
                  body: "## ðŸ¤– Devin AI Session (Fallback)\n\n**Vulnerability Type:** " + ruleId + "\n**Severity:** " + group.severity + "\n**Instances:** " + group.alerts.length + "\n**Original PR:** #" + prNumber + "\n**Target Branch:** " + headRef + "\n\n### Note:\nDevin API was not available. Manual remediation required.\n\n### Alerts:\n" + alertDetails + "\n\n---\n*This issue tracks security vulnerabilities that need manual remediation.*",
                  labels: ['security', 'manual-fix-required', 'severity-' + group.severity]
                });
              } else {
                const sessionData = await response.json();
                console.log("Created Devin session: " + sessionData.url);
                
                // Create tracking issue with real session
                await github.rest.issues.create({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  title: "ðŸ¤– Devin AI: Fix " + ruleId + " vulnerabilities (" + group.severity + ")",
                  body: "## ðŸ¤– Devin AI Session Created\n\n**Session URL:** " + sessionData.url + "\n**Session ID:** " + sessionData.session_id + "\n**Vulnerability Type:** " + ruleId + "\n**Severity:** " + group.severity + "\n**Instances:** " + group.alerts.length + "\n**Original PR:** #" + prNumber + "\n**Target Branch:** " + headRef + "\n\n### Alerts:\n" + alertDetails + "\n\n### What Devin AI Will Do:\n1. âœ… Analyze the CodeQL alerts\n2. âœ… Implement secure fixes\n3. âœ… Create a pull request with remediation\n4. âœ… Target fixes against your feature branch\n\n---\n*Monitor the Devin session above to track progress.*\n*Devin will create a separate PR with the actual security fixes.*",
                  labels: ['security', 'devin-ai', 'automated', 'severity-' + group.severity]
                });
              }
            } catch (error) {
              console.log("Error calling Devin API: " + error.message);
              // Create fallback tracking issue
              await github.rest.issues.create({
                owner: context.repo.owner,
                repo: context.repo.repo,
                title: "ðŸ¤– Devin AI: Fix " + ruleId + " vulnerabilities (" + group.severity + ") - MANUAL",
                body: "## ðŸ¤– Devin AI Session Failed\n\n**Error:** " + error.message + "\n**Vulnerability Type:** " + ruleId + "\n**Severity:** " + group.severity + "\n**Instances:** " + group.alerts.length + "\n**Original PR:** #" + prNumber + "\n**Target Branch:** " + headRef + "\n\n### Manual Remediation Required:\n" + alertDetails + "\n\n---\n*This issue requires manual security remediation.*",
                labels: ['security', 'manual-fix-required', 'severity-' + group.severity]
              });
            }
          }
          
          // Update the PR comment with dispatch status
          const dispatchCount = Object.keys(vulnerabilityGroups).length;
          await github.rest.issues.createComment({
            owner: context.repo.owner,
            repo: context.repo.repo,
            issue_number: context.issue.number,
            body: `ðŸš€ **Triggered ${dispatchCount} Devin AI remediation workflow(s)**\n\nEach vulnerability type will be addressed in a separate MR against your feature branch \`${headRef}\`.`
          });

    - name: Handle no alerts case
      if: steps.analyze-alerts.outputs.pr_alerts_count == 0
      uses: actions/github-script@v7
      with:
        script: |
          await github.rest.issues.createComment({
            owner: context.repo.owner,
            repo: context.repo.repo,
            issue_number: context.issue.number,
            body: `âœ… **No CodeQL alerts found in this PR**\n\nThe changed files in this PR do not contain any open CodeQL security alerts that require remediation.`
          });
