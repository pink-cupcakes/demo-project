name: "Security Remediation"

on:
  schedule:
    - cron: '0 6 * * *'  # Daily at 6 AM UTC
  workflow_dispatch:
    inputs:
      severity_filter:
        description: 'Minimum severity level to process'
        required: false
        default: 'medium'
        type: choice
        options:
        - low
        - medium
        - high
        - critical
      force_run:
        description: 'Force run even if no new alerts'
        required: false
        default: false
        type: boolean

jobs:
  process-security-alerts:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
      security-events: read
      actions: read

    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      with:
        token: ${{ secrets.GITHUB_TOKEN }}

    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '18'
        cache: 'npm'

    - name: Install dependencies
      run: npm ci

    - name: Get CodeQL alerts
      id: get-alerts
      uses: actions/github-script@v7
      with:
        script: |
          const { data: alerts } = await github.rest.codeScanning.listAlertsForRepo({
            owner: context.repo.owner,
            repo: context.repo.repo,
            state: 'open',
            per_page: 100
          });
          
          // Group alerts by vulnerability type
          const groupedAlerts = {};
          const severityOrder = { critical: 4, high: 3, medium: 2, low: 1 };
          const minSeverity = severityOrder['${{ github.event.inputs.severity_filter || 'medium' }}'] || 2;
          
          alerts.forEach(alert => {
            if (severityOrder[alert.rule.severity] >= minSeverity) {
              const category = alert.rule.id.split('/')[1] || 'misc';
              if (!groupedAlerts[category]) {
                groupedAlerts[category] = [];
              }
              groupedAlerts[category].push(alert);
            }
          });
          
          core.setOutput('grouped-alerts', JSON.stringify(groupedAlerts));
          core.setOutput('has-alerts', Object.keys(groupedAlerts).length > 0);
          
          return groupedAlerts;

    - name: Create remediation branches and PRs
      if: steps.get-alerts.outputs.has-alerts == 'true'
      uses: actions/github-script@v7
      with:
        script: |
          const groupedAlerts = JSON.parse('${{ steps.get-alerts.outputs.grouped-alerts }}');
          const timestamp = Math.floor(Date.now() / 1000);
          
          // Define remediation templates for common vulnerability types
          const remediationTemplates = {
            'command-line-injection': {
              title: 'Security: Fix command injection vulnerabilities',
              description: 'Addresses command injection vulnerabilities by implementing input validation and using safer alternatives to exec().',
              fixes: [
                'Replace direct exec() calls with parameterized alternatives',
                'Add input validation and sanitization',
                'Use allowlists for permitted commands/parameters'
              ]
            },
            'path-injection': {
              title: 'Security: Fix path traversal vulnerabilities', 
              description: 'Prevents path traversal attacks by validating and sanitizing file paths.',
              fixes: [
                'Validate file paths against allowlists',
                'Use path.resolve() and check if result is within allowed directory',
                'Sanitize user input before path operations'
              ]
            },
            'xss': {
              title: 'Security: Fix cross-site scripting vulnerabilities',
              description: 'Prevents XSS attacks by properly escaping user input in HTML contexts.',
              fixes: [
                'Escape user input before rendering in HTML',
                'Use template engines with auto-escaping',
                'Implement Content Security Policy headers'
              ]
            },
            'sql-injection': {
              title: 'Security: Fix SQL injection vulnerabilities',
              description: 'Prevents SQL injection by using parameterized queries.',
              fixes: [
                'Replace string concatenation with parameterized queries',
                'Use ORM/query builder with built-in protection',
                'Validate and sanitize all user inputs'
              ]
            },
            'hardcoded-credentials': {
              title: 'Security: Remove hardcoded credentials',
              description: 'Removes hardcoded secrets and implements secure credential management.',
              fixes: [
                'Move secrets to environment variables',
                'Use secure secret management systems',
                'Add secrets to .gitignore and remove from history'
              ]
            },
            'insecure-randomness': {
              title: 'Security: Fix insecure random number generation',
              description: 'Replaces insecure Math.random() with cryptographically secure alternatives.',
              fixes: [
                'Use crypto.randomBytes() for security-sensitive operations',
                'Implement proper entropy sources',
                'Add randomness validation'
              ]
            },
            'prototype-pollution': {
              title: 'Security: Fix prototype pollution vulnerabilities',
              description: 'Prevents prototype pollution by implementing safe object merging.',
              fixes: [
                'Add prototype pollution protection to merge functions',
                'Use Object.create(null) for safe objects',
                'Validate object keys before assignment'
              ]
            },
            'redos': {
              title: 'Security: Fix regular expression DoS vulnerabilities',
              description: 'Replaces vulnerable regex patterns with safer alternatives.',
              fixes: [
                'Replace catastrophic backtracking patterns',
                'Add input length limits',
                'Use alternative validation methods'
              ]
            }
          };
          
          for (const [category, alerts] of Object.entries(groupedAlerts)) {
            const template = remediationTemplates[category] || {
              title: `Security: Fix ${category} vulnerabilities`,
              description: `Addresses ${category} security vulnerabilities found by CodeQL analysis.`,
              fixes: ['Implement security fixes based on CodeQL recommendations']
            };
            
            const branchName = `security/fix-${category}-${timestamp}`;
            const alertCount = alerts.length;
            const highestSeverity = Math.max(...alerts.map(a => ({ critical: 4, high: 3, medium: 2, low: 1 })[a.rule.severity]));
            const severityLabel = Object.keys({ critical: 4, high: 3, medium: 2, low: 1 }).find(k => ({ critical: 4, high: 3, medium: 2, low: 1 })[k] === highestSeverity);
            
            // Create branch
            const { data: mainBranch } = await github.rest.repos.getBranch({
              owner: context.repo.owner,
              repo: context.repo.repo,
              branch: 'main'
            });
            
            await github.rest.git.createRef({
              owner: context.repo.owner,
              repo: context.repo.repo,
              ref: `refs/heads/${branchName}`,
              sha: mainBranch.commit.sha
            });
            
            // Create placeholder commit (actual fixes would be implemented by separate tooling)
            const commitMessage = `security: prepare fixes for ${category} vulnerabilities
            
Found ${alertCount} ${category} vulnerabilities with ${severityLabel} severity.
This commit prepares the branch for implementing security fixes.

Alerts to address:
${alerts.map(a => `- ${a.rule.description} (${a.html_url})`).join('\n')}`;
            
            const { data: readme } = await github.rest.repos.getContent({
              owner: context.repo.owner,
              repo: context.repo.repo,
              path: 'README.md',
              ref: branchName
            });
            
            const readmeContent = Buffer.from(readme.content, 'base64').toString();
            const updatedContent = readmeContent + `\n\n<!-- Security fixes for ${category} vulnerabilities - ${new Date().toISOString()} -->`;
            
            await github.rest.repos.createOrUpdateFileContents({
              owner: context.repo.owner,
              repo: context.repo.repo,
              path: 'README.md',
              message: commitMessage,
              content: Buffer.from(updatedContent).toString('base64'),
              sha: readme.sha,
              branch: branchName
            });
            
            // Create PR
            const prBody = `## Security Remediation: ${template.title}

${template.description}

### Vulnerabilities Addressed
- **Count**: ${alertCount} vulnerabilities
- **Severity**: ${severityLabel}
- **Category**: ${category}

### Planned Fixes
${template.fixes.map(fix => `- [ ] ${fix}`).join('\n')}

### CodeQL Alerts
${alerts.map(alert => `- [${alert.rule.description}](${alert.html_url}) - ${alert.rule.severity}`).join('\n')}

### Testing Checklist
- [ ] Verify fixes address all identified vulnerabilities
- [ ] Run security tests to confirm remediation
- [ ] Ensure no regression in functionality
- [ ] Update documentation if needed

---
*This PR was automatically created by the Security Remediation workflow.*
*Link to Devin run: https://app.devin.ai/sessions/a5c8f91058ae4b3187859c59b1101f11*
*Requested by: @pink-cupcakes*`;

            const { data: pr } = await github.rest.pulls.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: `${template.title} (${alertCount} issues)`,
              head: branchName,
              base: 'main',
              body: prBody,
              draft: false
            });
            
            // Add labels
            await github.rest.issues.addLabels({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: pr.number,
              labels: ['security', `severity:${severityLabel}`, 'automated']
            });
            
            console.log(`Created PR #${pr.number} for ${category} vulnerabilities: ${pr.html_url}`);
          }
